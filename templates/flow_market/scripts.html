{% load otree %}

<!-- Code heavily adopted from Jason Vranek (github.com/JasonVranek) (https://people.ucsc.edu/~jvranek/flow_viz.html) -->

<!-- prettier-ignore -->
{% block constants %} {% include Constants.scripts_constants_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block imports %} {% include Constants.scripts_imports_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block init_graphs %} {% include Constants.scripts_init_graphs_template %}
{% endblock %}
<!-- pretter-ignore -->
{% block init_sliders %} {% include Constants.scripts_init_sliders_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block InputDropdown %} {% include Constants.scripts_InputDropdown_template %}
{% endblock %}

<script>
  console.error("new_sell should be available")

  // DEBUG tick count
  let tickCount = 0
  const ticks = []

  // Do setup things
  document.addEventListener(
    'DOMContentLoaded',
    () => {
      if ('{{player.id_in_group}}' == 1) {
        liveSend({
          direction: 'begin',
        });
        console.log('begin round');
      }

      // Automate.start()

      InputDropdown.hideAlgorithmicInputDropdown();
      BetsUI.convertDeadlinesToSeconds();


      MarketGraph.updateAxesText()

      ROUND_NUMBER = parseInt(document.querySelector(".roundNum").textContent)
      console.log("HERE")
      console.log("**got roundNum:", ROUND_NUMBER, "query", document.querySelector(".roundNum"), "text", document.querySelector(".roundNum").textContent)

      setInterval(() => {
        // DEBUG tick count
        // ticks.push(tickCount)
        // const avg = ticks.reduce((acc, curr) => acc + curr) / ticks.length
        // console.log("ticks since last second:", tickCount, " avg:", avg.toFixed(2))
        // tickCount = 0

        updateCashAndInventoryDisplay(cachedDataForOdometer);
        BetsUI.decrementDeadlines();
      }, 1000);
    },
    false
  );

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  class DraggableGraphInput {
    // for keeping track if button is either "Send Buy" (true) or "Cancel Buy" (false)
    static isBuyButtonSend = true
    static isSellButtonSend = true

    static blueVal = 0;
    static redVal = 1;

    static topPointVal = 0;
    static yPointVal = 1;
    static middlePointVal = 2;
    static xPointVal = 3;

    static red_bottomPointVal = 0;
    static red_yPointVal = 1;
    static red_middlePointVal = 2;
    static red_topPointVal = 3;

    static blue_cdaTopPointVal = 0;
    static cdaYPointVal = 1;
    static cdaMiddlePoint = 2;
    static cdaTopPointVal = 3;
    static cdaBottomPointVal = 3;
    static cdaMiddlePointVal = 2

    static cdaTopLimit = 19;
    static cdaBottomLimit = 1;
    static cdaXLimit = 0.01;

    static pointMinDifference = 1;

    static floPointStyle = [
      document.querySelector("#blankPointStyle"),
      "circle",
      "rect",
      document.querySelector("#blankPointStyle")
    ];

    static cdaPointStyle = [
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      "rect",
      document.querySelector("#blankPointStyle")
    ];

    static floPointStyleBlank = [
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle")
    ];

    static cdaPointStyleBlank = [
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle")
    ];

    static floDataAsks = [
      {
        x: 0, // point going to y = 0
        y: 0
      },
      {
        x: 0, // circle
        y: 17
      },
      {
        x: 0, // square
        y: 19
      },
      {
        x: 0, // point going to y = 20, same x as middle point
        y: 20
      }
    ];

    static floDataBids = [
      {
        x: 0, // point going to y = 20
        y: 20
      },
      {
        x: 0, // circle
        y: 3
      },
      {
        x: 0, // square
        y: 1
      },
      {
        x: 0, // point going to y = 0, same x as middle point
        y: 0
      }
    ];

    // for when middlePoint is x = 0, to allow for dragging of middlePoint instead of yPoint, since yPoint's z index is larger than middlePoint
    static CDA_DRAG_BUG_FIX = 1;

    static cdaDataAsks = [
      {
        x: 0, // bottom point
        y: 0
      },
      {
        x: 0, // x point, x always 0, y always same as middle point (initial has .1 to fix drag bug)
        y: 17 - this.CDA_DRAG_BUG_FIX
      },
      {
        x: 0, // mid point
        y: 17
      },
      // todo add point here then change cda points
      {
        x: 0, // top point
        y: 20
      },
    ];

    static cdaDataBids = [
      // todo add point here then change cda points
      {
        x: 0, // top point
        y: 20
      },
      {
        x: 0, // x point, x always 0, y always same as middle point
        y: 3 + this.CDA_DRAG_BUG_FIX
      },
      {
        x: 0, // middle point
        y: 3
      },
      {
        x: 0, // bottom point
        y: 0
      }
    ];

    // used for reverting to intial data
    static floDataAsksCopy = JSON.parse(JSON.stringify(this.floDataAsks))
    static floDataBidsCopy = JSON.parse(JSON.stringify(this.floDataBids))

    static cdaDataAsksCopy = JSON.parse(JSON.stringify(this.cdaDataAsks))
    static cdaDataBidsCopy = JSON.parse(JSON.stringify(this.cdaDataBids))

    static removeBlueHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyleBlank : DraggableGraphInput.cdaPointStyleBlank
      DraggableGraphInput.myLineChart.update();
    }

    static putBackBlueHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle
      DraggableGraphInput.myLineChart.update();
    }

    static removeRedHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyleBlank : DraggableGraphInput.cdaPointStyleBlank
      DraggableGraphInput.myLineChart.update();
    }

    static putBackRedHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle
      DraggableGraphInput.myLineChart.update();
    }

    static makeRedTransparent() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["borderColor"] = RED_TRANSPARENT;
      // shouldn't change handle color
      // DraggableGraphInput.myLineChart.data.datasets[this.redVal]["backgroundColor"] = RED_TRANSPARENT;
      DraggableGraphInput.myLineChart.update();
    }

    static shouldDisableRedDrag = false
    static shouldDisableBlueDrag = false

    static showBlueActive() {
      DraggableGraphInput.makeBlueOpaque()
      DraggableGraphInput.disableBlueDrag()
      DraggableGraphInput.removeBlueHandles()
    }

    static showBlueInactive() {
      console.log("blue should be inactive")
      DraggableGraphInput.goToInitialPositionBlue()
      DraggableGraphInput.makeBlueTransparent()
      DraggableGraphInput.enableBlueDrag()
      DraggableGraphInput.putBackBlueHandles()
      DraggableGraphInput.myLineChart.update()
    }

    static showRedActive() {
      DraggableGraphInput.makeRedOpaque()
      DraggableGraphInput.disableRedDrag()
      DraggableGraphInput.removeRedHandles()
    }

    static showRedInactive() {
      DraggableGraphInput.goToInitialPositionRed()
      DraggableGraphInput.makeRedTransparent()
      DraggableGraphInput.enableRedDrag()
      DraggableGraphInput.putBackRedHandles()
      DraggableGraphInput.myLineChart.update()
    }

    static disableRedDrag() {
      DraggableGraphInput.shouldDisableRedDrag = true
    }

    static enableRedDrag() {
      DraggableGraphInput.shouldDisableRedDrag = false
    }

    static disableBlueDrag() {
      DraggableGraphInput.shouldDisableBlueDrag = true
    }

    static enableBlueDrag() {
      DraggableGraphInput.shouldDisableBlueDrag = false
    }

    static makeRedOpaque() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["borderColor"] = RED;
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["backgroundColor"] = RED;
      DraggableGraphInput.myLineChart.update();
    }

    static makeBlueOpaque() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["borderColor"] = BLUE;
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["backgroundColor"] = BLUE;
      DraggableGraphInput.myLineChart.update();
    }

    static makeBlueTransparent() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["borderColor"] = BLUE_TRANSPARENT;
      // don't change handle color
      // DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["backgroundColor"] = BLUE_TRANSPARENT;
      DraggableGraphInput.myLineChart.update();
    }

    static expirationTimeInput = document.querySelector("#expirationTimeInput")
    static getDraggableGraphBidData() {
      // console.log(myLineChart.data.datasets[blueVal]["data"]);
      let minPrice
      let maxPrice
      let volume
      let uMax
      let expirationTimeInput

      if (isFLO) {
        maxPrice = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.yPointVal]["y"];
        minPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.middlePointVal]["y"];
        uMax = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.middlePointVal]["x"];
        // volume = 50
        volume = parseInt(DraggableGraphInput.buyVolInput.value, 10)
        console.log("**got vol:", typeof volume)

        // console.log("buy:", DraggableGraphInput.buyVolInput.value)
        // console.log("sell:", DraggableGraphInput.sellVolInput.value)

        console.log(minPrice, maxPrice, uMax);

      } else if (isCDA) {
        maxPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePoint]["y"];
        volume = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePointVal]["x"];
        minPrice = maxPrice
        uMax = parseInt('{{max_u_max}}');
        console.log("send order", maxPrice, volume);
      }

      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)
      console.log("**time0:", this.expirationTimeInput)
      console.log("**time0:", expirationTimeInput)

      return { minPrice, maxPrice, volume, uMax, expirationTimeInput }
    }

    static getDraggableGraphAlgoBidData() {
      // console.log(myLineChart.data.datasets[blueVal]["data"]);
      let minPrice // y-axis
      let maxPrice // same as minPrice
      let unitsAtATime // x-axis
      let uMax // set by default setting
      let totalVolume // input value
      let expirationTimeInput

      // p_min: minPrice,
      // p_max: maxPrice,
      // q_max: unitsAtATime, // units at a time, should be determined by x-axis
      // q_total: tempTotalVolume, // should be determined by input field

      maxPrice =
        DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePoint]["y"];
      unitsAtATime = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePointVal]["x"];
      minPrice = maxPrice
      uMax = parseInt('{{max_u_max}}');
      totalVolume = parseInt(DraggableGraphInput.buyVolInput.value, 10)
      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)

      console.log("**time1:", expirationTimeInput)

      return {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume,
        expirationTimeInput
      }
    }

    static getDraggableGraphAskData() {
      console.log("got** ask data")
      let minPrice
      let maxPrice
      let volume
      let uMax
      let expirationTimeInput

      // console.log(myLineChart.data.datasets[redVal]["data"]);
      if (isFLO) {
        minPrice = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.yPointVal]["y"];
        maxPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["y"];
        uMax = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["x"];
        // volume = 50;
        volume = parseInt(DraggableGraphInput.sellVolInput.value, 10)
        console.log(minPrice, maxPrice, uMax);
      } else if (isCDA) {
        maxPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.cdaMiddlePoint]["y"];
        volume = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["x"];
        minPrice = maxPrice
        uMax = parseInt('{{max_u_max}}');
        console.log(maxPrice, volume);
      }

      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)

      return { minPrice, maxPrice, volume, uMax, expirationTimeInput }
    }

    static getDraggableGraphAlgoAskData() {
      let minPrice // y-axis
      let maxPrice // same as minPrice
      let unitsAtATime // x-axis
      let uMax // set by default setting
      let totalVolume // input value
      let expirationTimeInput

      // p_min: minPrice,
      // p_max: maxPrice,
      // q_max: unitsAtATime, // units at a time, should be determined by x-axis
      // q_total: tempTotalVolume, // should be determined by input field

      maxPrice =
        DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.cdaMiddlePoint]["y"];
      unitsAtATime = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["x"];
      minPrice = maxPrice
      uMax = parseInt('{{max_u_max}}');
      totalVolume = parseInt(DraggableGraphInput.sellVolInput.value, 10)
      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)

      return {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume
      }
    }

    static config = {
      responsive: true,
      maintainAspectRatio: false,

      plugins: {
        tooltip: { enabled: false },
        dragData: {
          round: 0,
          dragX: true,
          showTooltip: true,

          // controls the ability to start dragging
          onDragStart: function (e, datasetIndex, index, value) {
            const isBlue = datasetIndex === DraggableGraphInput.blueVal;
            const isRed = datasetIndex === DraggableGraphInput.redVal;

            if (isBlue && DraggableGraphInput.shouldDisableBlueDrag) {
              return false
            }

            if (isRed && DraggableGraphInput.shouldDisableRedDrag) {
              return false
            }

            if (isFLO) {
              // disable ability to start dragging for x point and top point
              if (isBlue) {
                // DraggableGraphInput.makeBlueOpaque();
                // DraggableGraphInput.makeRedTransparent();

                const isYPoint = index === DraggableGraphInput.yPointVal;
                const isMiddlePoint = index === DraggableGraphInput.middlePointVal;
                const isXPoint = index === DraggableGraphInput.xPointVal;
                const isTopPoint = index === DraggableGraphInput.topPointVal;

                if (isXPoint || isTopPoint) {
                  return false;
                }
              } else if (isRed) {
                // DraggableGraphInput.makeRedOpaque();
                // DraggableGraphInput.makeBlueTransparent();

                const isYPoint = index === DraggableGraphInput.red_yPointVal;
                const isBottomPoint = index === DraggableGraphInput.red_bottomPointVal;
                const isTopPoint = index === DraggableGraphInput.red_topPointVal;

                if (isBottomPoint || isTopPoint) {
                  return false;
                }
              }
            } else if (isCDA) {
              // disable ability to start dragging for x point and top point
              if (isBlue) {
                // DraggableGraphInput.makeBlueOpaque();
                // DraggableGraphInput.makeRedTransparent();
                console.log("index", index, DraggableGraphInput.cdaMiddlePointVal)
                if (index !== DraggableGraphInput.cdaMiddlePointVal) return false

                // const isYPoint = index === DraggableGraphInput.cdaYPointVal;
                // const isTopPoint = index === DraggableGraphInput.blue_cdaTopPointVal;
                // console.log("drag start", index, "yPoint", isYPoint, "topPoint", isTopPoint)

                // if (isYPoint) {
                //   return false;
                // }

                // if (isTopPoint) {
                //   return false;
                // }
              } else if (isRed) {
                console.log("index", index, DraggableGraphInput.cdaMiddlePointVal)
                if (index !== DraggableGraphInput.cdaMiddlePointVal) return false
                // DraggableGraphInput.makeRedOpaque();
                // DraggableGraphInput.makeBlueTransparent();

                // const isYPoint = index === DraggableGraphInput.cdaYPointVal;
                // const isTopPoint = index === DraggableGraphInput.cdaTopPointVal;
                // if (index === 0 || index == 2 || index === 3) return false // todo check
                // if (isYPoint) {
                //   return false;
                // }

                // if (isTopPoint) {
                //   return false;
                // }
              }
            }
          },

          onDrag: function (e, datasetIndex, index, value) {
            const isBlue = datasetIndex === DraggableGraphInput.blueVal;
            const isRed = datasetIndex === DraggableGraphInput.redVal;

            const bottomYLimit = 1;
            const topYLimit = 19;

            e.target.style.cursor = "grabbing";

            if (isFLO) {
              if (isBlue) {
                const isYPoint = index === DraggableGraphInput.yPointVal;
                const isMiddlePoint = index === DraggableGraphInput.middlePointVal;
                const isXPoint = index === DraggableGraphInput.xPointVal;

                // update xPoint when middlePoint is dragged
                if (isMiddlePoint) {
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.xPointVal]["x"] =
                    value["x"];

                  // prevent yPoint going below limit
                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.middlePointVal][
                      "y"
                    ] = bottomYLimit;
                  }
                }

                // cont here
                if (isYPoint) {
                  console.log("**isYPoint")
                  // prevent yPoint going above top y limit
                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal][
                      "y"
                    ] = bottomYLimit;
                  }
                  if (value["y"] >= topYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal][
                      "y"
                    ] = topYLimit;
                  }

                  const middlePointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.middlePointVal]["y"];

                  // prevent yPoint going below middle
                  if (value["y"] <= middlePointYVal) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"] =
                      middlePointYVal + DraggableGraphInput.pointMinDifference;
                  }

                  // prevent blue yPoint going above red yPoint
                  const redYPoint = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"]
                  if (value["y"] >= redYPoint) {
                    console.log("**here", redYPoint)
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"] = redYPoint - DraggableGraphInput.pointMinDifference
                  }

                  // prevent yPoint moving on x-axis
                  if (value["x"] > 0) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["x"] = 0;
                  }
                }

                // blue, prevent middlePoint going above yPoint
                if (isMiddlePoint) {
                  const yPointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"];
                  if (value["y"] >= yPointYVal) {
                    value["y"] = yPointYVal - DraggableGraphInput.pointMinDifference;
                  }
                }
              } else if (isRed) {
                const isYPoint = index === DraggableGraphInput.red_yPointVal;
                const isMiddlePoint = index === DraggableGraphInput.red_middlePointVal;
                const isTopPoint = index === DraggableGraphInput.red_topPointVal;

                if (isMiddlePoint) {
                  // update topPoint when middlePoint is dragged
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_topPointVal]["x"] =
                    value["x"];

                  // prevent middlePoint going above top y limit
                  if (value["y"] >= topYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_middlePointVal][
                      "y"
                    ] = topYLimit;
                  }

                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_middlePointVal][
                      "y"
                    ] = bottomYLimit;
                  }
                }

                if (isYPoint) {
                  const middlePointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_middlePointVal]["y"];

                  // prevent yPoint going above limit
                  if (value["y"] >= topYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal][
                      "y"
                    ] = topYLimit;
                  }

                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal][
                      "y"
                    ] = bottomYLimit;
                  }

                  // prevent red yPoint going above blue yPoint
                  // cont: test this
                  const blueYPoint = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"]
                  if (value["y"] <= blueYPoint) {
                    console.log("**here", blueYPoint)
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"] = blueYPoint + DraggableGraphInput.pointMinDifference
                  }

                  // prevent yPoint going above middle
                  if (value["y"] >= middlePointYVal) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"] =
                      middlePointYVal - DraggableGraphInput.pointMinDifference;
                  }

                  // prevent yPoint moving on x-axis
                  if (value["x"] > 0) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["x"] = 0;
                  }
                }

                // prevent middlePoint going below middle
                if (isMiddlePoint) {
                  const yPointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"];

                  if (value["y"] <= yPointYVal) {
                    value["y"] = yPointYVal + DraggableGraphInput.pointMinDifference;
                  }

                  if (value["y"] <= bottomYLimit) {
                    value["y"] = bottomYLimit;
                  }
                }
              }
            } else if (isCDA) {
              if (isBlue) {
                const isMiddlePoint = index === DraggableGraphInput.cdaMiddlePoint;
                // make bottomPoint
                if (isMiddlePoint) {
                  // prevent crossing
                  if (value["y"] >= DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"]) {
                    console.log("corssing")
                    value["y"] = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"] - DraggableGraphInput.pointMinDifference
                  }

                  // don't let go above top limit
                  if (value["y"] >= DraggableGraphInput.cdaTopLimit) {
                    value["y"] = DraggableGraphInput.cdaTopLimit;
                  }

                  // don't let go below bottom limit
                  if (value["y"] <= DraggableGraphInput.cdaBottomLimit) {
                    value["y"] = DraggableGraphInput.cdaBottomLimit;
                  }

                  // set y point to same y value as middle point
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                    value["y"];

                  // not sure what cdaXLimit is for...
                  if (value["x"] <= DraggableGraphInput.cdaXLimit) {
                    value["x"] = DraggableGraphInput.cdaXLimit;

                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                      value["y"] + DraggableGraphInput.CDA_DRAG_BUG_FIX;
                  }

                  // set the x point to the same x value as middle point
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaBottomPointVal]["x"] =
                    value["x"];

                }
              } else if (isRed) {
                const isMiddlePoint = index === DraggableGraphInput.cdaMiddlePoint;
                // make bottomPoint
                if (isMiddlePoint) {
                  // prevent crossing
                  if (value["y"] <= DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"]) {
                    console.log("corssing 2")
                    value["y"] = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"] + DraggableGraphInput.pointMinDifference
                  }

                  if (value["y"] >= DraggableGraphInput.cdaTopLimit) {
                    value["y"] = DraggableGraphInput.cdaTopLimit;
                  }

                  if (value["y"] <= DraggableGraphInput.cdaBottomLimit) {
                    value["y"] = DraggableGraphInput.cdaBottomLimit;
                  }

                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                    value["y"];

                  if (value["x"] <= DraggableGraphInput.cdaXLimit) {
                    value["x"] = DraggableGraphInput.cdaXLimit;

                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                      value["y"] - DraggableGraphInput.CDA_DRAG_BUG_FIX;
                  }

                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaTopPointVal]["x"] =
                    value["x"];
                }
              }
            }

          },

          onDragEnd: function (e, datasetIndex, index, value) {
            e.target.style.cursor = "default";
          }
        }
      },

      onHover: (e, chartElement) => {
        // change cursor if hovering over a point
        if (chartElement[0] != null) {
          if (isFLO) {
            // don't change hover for blue x-axis point and top point
            const isBluePoint = chartElement[0].datasetIndex === DraggableGraphInput.blueVal;
            const isXPoint = chartElement[0].index === DraggableGraphInput.xPointVal;
            const isTopPoint = chartElement[0].index === DraggableGraphInput.topPointVal;

            const isRedPoint = chartElement[0].datasetIndex === DraggableGraphInput.redVal;
            const isRedBottomPoint = chartElement[0].index === DraggableGraphInput.red_bottomPointVal;
            const isRedTopPoint = chartElement[0].index === DraggableGraphInput.red_topPointVal;

            if (isRedPoint && DraggableGraphInput.shouldDisableRedDrag) {
              return
            }
            if (isBluePoint && DraggableGraphInput.shouldDisableBlueDrag) {
              return
            }

            if (isBluePoint && !isXPoint && !isTopPoint) {
              document.querySelector("#draggableGraphInput").style.cursor = "grab";
            }

            if (isRedPoint && !isRedBottomPoint && !isRedTopPoint) {
              document.querySelector("#draggableGraphInput").style.cursor = "grab";
            }
          } else if (isCDA) {
            const isBluePoint = chartElement[0].datasetIndex === DraggableGraphInput.blueVal;
            const isRedPoint = chartElement[0].datasetIndex === DraggableGraphInput.redVal;
            const isMiddlePoint = chartElement[0].index === DraggableGraphInput.cdaMiddlePoint;

            if (isRedPoint && DraggableGraphInput.shouldDisableRedDrag) {
              return
            }
            if (isBluePoint && DraggableGraphInput.shouldDisableBlueDrag) {
              return
            }

            if (isMiddlePoint) {
              document.querySelector("#draggableGraphInput").style.cursor = "grab";
            }
          }
        } else {
          document.querySelector("#draggableGraphInput").style.cursor = "default";
        }
      },

      hover: {
        intersect: true
      },

      scales: {
        y: {
          title: {
            display: true,
            text: isCDA || isFBA ? "Price" : "Price"
          },
          beginAtZero: true,

          suggestedMin: 0, // TODO maybe remove after dan's video
          suggestedMax: 20
        },

        x: {
          title: {
            display: true,
            text: isCDA || isFBA ? "Volume" : "Rate"
          },
          beginAtZero: true,

          suggestedMin: 1, // TODO maybe remove after dan's video
          suggestedMax: isCDA || isFBA ? 100 : 5
        }
      }
    };

    static myLineChart = new Chart(document.querySelector("#draggableGraphInput"), {
      type: "scatter",
      data: {
        datasets: [
          {
            borderWidth: 2,
            pointStyle: "line",

            label: "Bids",
            borderColor: BLUE_TRANSPARENT,
            backgroundColor: BLUE,
            fill: false,
            showLine: true,

            pointStyle: isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle,

            pointRadius: 6,
            lineTension: 0,
            pointHitRadius: 25,
            data: isFLO ? DraggableGraphInput.floDataBids : DraggableGraphInput.cdaDataBids
          },
          {
            borderWidth: 2,
            pointStyle: "line",

            label: "Asks",
            borderColor: RED_TRANSPARENT,
            backgroundColor: RED,
            fill: false,
            showLine: true,
            lineTension: 0,

            pointStyle: isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle,

            pointRadius: 6,
            lineTension: 0,
            pointHitRadius: 25,
            data: isFLO ? DraggableGraphInput.floDataAsks : DraggableGraphInput.cdaDataAsks
          }
        ]
      },

      options: DraggableGraphInput.config
    });

    static goToInitialPositionRed() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["data"] = isFLO ? JSON.parse(JSON.stringify(DraggableGraphInput.floDataAsksCopy)) : JSON.parse(JSON.stringify(DraggableGraphInput.cdaDataAsksCopy))
      DraggableGraphInput.myLineChart.update();
    }

    static goToInitialPositionBlue() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["data"] = isFLO ? JSON.parse(JSON.stringify(DraggableGraphInput.floDataBidsCopy)) : JSON.parse(JSON.stringify(DraggableGraphInput.cdaDataBidsCopy))
      console.log("***data:", DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["data"])
      DraggableGraphInput.myLineChart.update()
    }

    static sendNewBuyFromDraggableGraph() {
      let { minPrice, maxPrice, volume, uMax, expirationTimeInput } = DraggableGraphInput.getDraggableGraphBidData()

      // expirationTimeInput = 99
      console.log("**time:", expirationTimeInput)
      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: volume,
        u_max: isFLO ? uMax : parseInt('{{max_u_max}}'),
        direction: 'buy',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentBuyOrder = order

      const valueToBeat = isNewOrderValid(order); // undefined means order is valid

      if (valueToBeat === undefined) {
        orderHistory.push(order);
        appendActiveOrdersTable(order);
        liveSend(order);
      } else {
        let errorText;
        if (isCDA || isFBA) {
          // cda/fba: can only buy when buy's p_max < sell's p_max
          // cda/fba: can only sell when sell's p_max > buy's p_max
          errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
        } else if (isFLO) {
          // flo: can only sell when p_min is > buy's p_max
          // flo: can only buy when p_max < sell's p_min
          errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
        }

        Swal.fire({
          title: 'Cannot Trade With Yourself',
          icon: 'warning',
          text: errorText,
          showClass: {
            popup: 'animate__animated animate__fadeIn',
          },
        });
      }
    }

    // TODO: copy from new_algo_buy
    static sendNewAlgoBuyFromDraggableGraph() {
      let {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume,
        expirationTimeInput
      } = this.getDraggableGraphAlgoBidData();

      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: unitsAtATime, // units at a time, should be determined by x-axis
        u_max: uMax,
        direction: 'algo_buy',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),

        q_total: totalVolume, // should be determined by input field
        executed_units: 0,
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentBuyOrder = order

      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);

      console.log("**sent algo buy order: ", order)
    }

    static handleCancelBuyButtonClick() {
      let order = JSON.parse(JSON.stringify(this.recentBuyOrder))
      order.direction = 'cancel'

      liveSend(order);
    }

    static handleCancelSellButtonClick() {
      let order = JSON.parse(JSON.stringify(this.recentSellOrder))
      order.direction = 'cancel'

      liveSend(order);
    }

    static algoToggle = false;

    static handleBuyButtonClick() {
      if (!this.isBuyButtonSend) {
        this.turnBuyButtonSend()
        this.handleCancelBuyButtonClick()
        // this.sendBuyOrderCancellation()
      } else {
        // turn button to "Cancel Sell"
        this.turnBuyButtonCancel()
        this.isBuyButtonSend = false

        if (this.algoToggle) {
          this.sendNewAlgoBuyFromDraggableGraph()
        } else {
          this.sendNewBuyFromDraggableGraph()
        }
      }
    }

    static handleSellButtonClick() {
      if (!this.isSellButtonSend) {
        this.turnSellButtonSend()
        this.handleCancelSellButtonClick()
        // this.sendSellOrderCancellation()
      } else {
        // turn button to "Cancel Sell"
        this.turnSellButtonCancel()
        this.isSellButtonSend = false

        if (this.algoToggle) {
          this.sendNewAlgoSellFromDraggableGraph()
        } else {
          this.sendNewSellFromDraggableGraph()
        }
      }
    }

    static recentSellOrder = null
    static recentBuyOrder = null

    static sendNewSellFromDraggableGraph() {
      let { minPrice, maxPrice, volume, uMax, expirationTimeInput } = DraggableGraphInput.getDraggableGraphAskData()

      if (minPrice > maxPrice) {
        console.error("minPrice > maxPrice")
        return
      }

      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: volume,
        u_max: uMax,
        direction: 'sell',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentSellOrder = order
      console.log("**sendSell order:", order)

      const valueToBeat = isNewOrderValid(order); // undefined means order is good
      if (valueToBeat === undefined) {
        console.log("**sendSell order1:", order)
        orderHistory.push(order);
        appendActiveOrdersTable(order);
        liveSend(order);
      } else {
        let errorText;
        if (isCDA || isFBA) {
          // cda/fba: can only buy when buy's p_max < sell's p_max
          // cda/fba: can only sell when sell's p_max > buy's p_max
          errorText = `Your sell order will cross with one of your buy orders. Try increasing the price above ${valueToBeat}.`;
        } else if (isFLO) {
          // flo: can only sell when p_min is > buy's p_max
          // flo: can only buy when p_max < sell's p_min
          errorText = `Your sell order will cross with one of your buy orders. Try increasing the minimum price above ${valueToBeat}.`;
        }

        Swal.fire({
          title: 'Cannot Trade With Yourself',
          icon: 'warning',
          text: errorText,
          showClass: {
            popup: 'animate__animated animate__fadeIn',
          },
        });
      }
    }

    static sendNewAlgoSellFromDraggableGraph() {
      let {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume,
        expirationTimeInput
      } = this.getDraggableGraphAlgoAskData();

      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: unitsAtATime, // units at a time, should be determined by x-axis
        u_max: uMax,
        direction: 'algo_sell',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),

        q_total: totalVolume, // should be determined by input field
        executed_units: 0,
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentBuyOrder = order

      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);

      console.log("sent algo buy order: ", order)
    }

    static buyButton = document.querySelector("#sendBidDraggableGraphInput")
    static sellButton = document.querySelector("#sendAskDraggableGraphInput")

    static buyVolInput = document.querySelector("#buyVolumeInput")
    static sellVolInput = document.querySelector("#sellVolumeInput")

    static turnBuyButtonCancel() {
      this.buyButton.innerText = "Cancel Buy"
      this.buyButton.classList.remove('btn-primary');
      this.buyButton.classList.add('btn-outline-primary');

      this.showBlueActive()
    }

    static turnBuyButtonSend() {
      this.buyButton.innerText = "Send Buy"
      this.buyButton.classList.add('btn-primary');
      this.buyButton.classList.remove('btn-outline-primary');

      this.showBlueInactive()
      this.isBuyButtonSend = true
    }

    static turnSellButtonCancel() {
      this.sellButton.innerText = "Cancel Sell"
      this.sellButton.classList.remove('btn-danger');
      this.sellButton.classList.add('btn-outline-danger');

      this.showRedActive()
    }

    static turnSellButtonSend() {
      this.sellButton.innerText = "Send Sell"
      this.sellButton.classList.add('btn-danger');
      this.sellButton.classList.remove('btn-outline-danger');

      this.showRedInactive()
      this.isSellButtonSend = true
    }

    static handleAlgorithmicOrderToggle(e) {
      this.algoToggle = e.target.checked

      // Change x-axis
      if (this.algoToggle) {
        this.config.scales.x.title.text = "Units at a Time"
      } else {
        this.config.scales.x.title.text = "Volume"
      }

      this.myLineChart.options = this.config
      this.myLineChart.update()
    }
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  let orderHistory = [];

  // update order history if an order has expired
  function updateOrderHistory(data) {
    console.log("**cancel", data, orderHistory)
    orderHistory = orderHistory.filter((order) => {
      console.log("**cancel do i come here?", order)
      let arrayToSearch;
      if (order.direction === 'buy' || order.direction === 'algo_buy') arrayToSearch = data.buys;
      if (order.direction === 'sell' || order.direction === 'algo_sell') arrayToSearch = data.sells;
      if (arrayToSearch === undefined) console.error('updateOrderHistory()');

      console.log("**cancel arrayToSearch", arrayToSearch)

      const orderInData = arrayToSearch.find((orderInData) => {
        return orderInData.orderID === order.orderID;
      });

      console.log("**cancel got id:", orderInData)

      if (orderInData === undefined) {
        console.error('orderInData undefined', order);
      }

      if (orderInData === undefined || orderInData.status === 'expired') {
        console.log("**algoCancel: got order:", orderInData)

        // turn "Cancel Buy" button into "Send Buy"
        if (order.direction === 'buy' || order.direction === 'algo_buy')
          DraggableGraphInput.turnBuyButtonSend();
        if (order.direction === 'sell' || order.direction === 'algo_sell')
          DraggableGraphInput.turnSellButtonSend();

        // remove from active orders table
        removeActiveOrderTable(order.orderID);


        return false;
      } else {
        return true;
      }
    });
  }

  // check if potential order does not conflict with any orders in orderHistory
  function isNewOrderValid(newOrder) {
    if (orderHistory.length === 0) return undefined;

    // cda/fba: can only buy when buy's p_max < sell's p_max
    // cda/fba: can only sell when sell's p_max > buy's p_max
    let numToBeValid;
    if (isCDA || isFBA) {
      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_max < minPrice ? order.p_max : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }

      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_max > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }
    }

    // flo: can only sell when p_min is > buy's p_max
    // flo: can only buy when p_max < sell's p_min
    if (isFLO) {
      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_min > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }

      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_min < minPrice ? order.p_min : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }
    }

    return numToBeValid;
  }

  ///////////////////////////////////////////////////////////////////////////////////

  var ctx = document.getElementById('myChart').getContext('2d');
  class MarketGraph {
    static flipAxes = true

    static flipGraphAxes() {
      MarketGraph.flipAxes = !MarketGraph.flipAxes
      MarketGraph.regraphAllGraphs()
      MarketGraph.updateAxesText()
    }

    static regraphAllGraphs() {
      graphClearingPrice(klf_line, null, null, null, true)

      graphBids(klf_line, null, true)

      graphAsks(klf_line, null, true)
    }

    static updateAxesText() {
      if (isCDA || isFBA) {
        if (MarketGraph.flipAxes) {
          klf_line.options.scales.x.title.text = "Volume            "
          klf_line.options.scales.y.title.text = "Price"
        } else {
          klf_line.options.scales.x.title.text = "Price            "
          klf_line.options.scales.y.title.text = "Volume"
        }
      } else if (isFLO) {
        console.log("**flipping")
        if (MarketGraph.flipAxes) {
          console.log("** 1flipping")
          klf_line.options.scales.x.title.text = "Rate             "
          klf_line.options.scales.y.title.text = "Price"
        } else {
          console.log("** 2flipping")
          klf_line.options.scales.x.title.text = "Price                "
          klf_line.options.scales.y.title.text = "Rate"
        }
      }

      klf_line.update()
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////

  const graphs = init_graphs();
  const klf_line = graphs[2];
  const cash_bar = graphs[0];
  const inventory_bar = graphs[1];

  const slider = createNoUiPriceSlider();
  const noUiVolSlider = createNoUiVolSlider();
  const noUiRateSlider = createNoUiRateSlider();

  const noUiAlgoTimeSlider = createNoUiAlgoTimeSlider();
  const noUiAlgoQuantitySlider = createNoUiAlgoQuantitySlider();
  const noUiAlgoPriceSlider = createNoUiAlgoPriceSlider();
  const noUiAlgoVolSlider = createnoUiAlgoVolSlider();
  const noUiAlgoRateSlider = createNoUiAlgoRateSlider();

  const [cashOdometer, invOdometer] = intializeOdometers();

  if ('{{treatment}}' != 'flo') {
    // Because cda and fba has a fixed u_max
    document.querySelector('.noUiRateSliderWrapper').remove();
    document.querySelector('.noUiAlgoRateSliderWrapper').remove();
  }

  function calcDemand(buy, price) {
    if (price <= buy.p_min) {
      if (buy.q_max < buy.u_max) {
        // Don't trade more than q_max
        return buy.q_max;
      }
      // Trade at max rate if p <= p_min
      return buy.u_max;
    } else if (price > buy.p_max) {
      // Don't trade if price is higher than max willingness to buy
      return 0.0;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
      if (trade_vol > buy.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return buy.q_max;
      }
      return trade_vol;
    }
  }

  function calcSupply(sell, price) {
    if (price < sell.p_min) {
      // Don't trade if price is lower than min willingness to sell
      return 0.0;
    } else if (price >= sell.p_max) {
      if (sell.q_max < sell.u_max) {
        // Don't trade more than q_max
        return sell.q_max;
      }
      // Trade at max rate if p >= p_max
      return sell.u_max;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        sell.u_max +
        ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
      if (trade_vol > sell.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return sell.q_max;
      }
      return trade_vol;
    }
  }

  let lastDataToGraphClearingPrice = {
    price: undefined,
    buys: undefined,
    sells: undefined
  }

  function graphClearingPrice(chart, price = null, buys = null, sells = null, regraph = false) {

    if (regraph === true && price === null && sells === null && buys === null) {
      if (chart.data.datasets[2].data.length === 0) return
      let { price, buys, sells } = lastDataToGraphClearingPrice
    } else {
      lastDataToGraphClearingPrice = { price, buys, sells }
    }

    console.log("cached graph clearing price:", lastDataToGraphClearingPrice)


    buys = buys.filter((buy) => buy['status'] == 'active');
    sells = sells.filter((sell) => sell['status'] == 'active');

    var agg_supply = 0.0; // agg_supply will be equal to agg_demand
    sells.forEach(function (sell, _index, _array) {
      agg_supply += calcSupply(sell, price);
    });

    var points = [];

    if (MarketGraph.flipAxes) {
      points.push({ x: 0.0, y: price });
      points.push({ x: agg_supply, y: price });
      points.push({ x: agg_supply, y: 0.0 });
    } else {
      points.push({ x: 0.0, y: agg_supply });
      points.push({ x: price, y: agg_supply });
      points.push({ x: price, y: 0.0 });
    }

    chart.data.datasets[2].data = points;
    chart.update();
  }

  let lastDataToGraphBids
  function graphBids(chart, buys = null, regraph = false) {
    console.log("graphBids() buys:")
    console.log(buys)
    console.log("")

    if (regraph === true && buys === null) {
      if (chart.data.datasets[0].data.length === 0) return
      buys = lastDataToGraphBids
    } else {
      lastDataToGraphBids = buys
    }

    buys = buys.filter((buy) => buy['status'] == 'active');

    if ('{{treatment}}' != 'cda') {

      // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
      if (buys.length == 0) {
        chart.data.datasets[0].data = [];
        chart.update();
        return;
      }

      var points = [];

      // Generate range(70, 130) the domain based on sliders values
      // var prices = Array.from(new Array(0), (x,i) => i + 20);
      var prices = [...Array(20).keys()];
      // prices = [0 to 20 integers]
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        buys.forEach(function (buy, _index, _array) {
          agg_supply += calcDemand(buy, price);
        });

        // console.log('graphBids() plotting x:', price, 'y:', agg_supply);
        points.push({
          x: price,
          y: agg_supply,
        });

      });
    } else {
      // if treatment is cda, sort the buy orders,
      buys.sort((a, b) => (a['p_max'] < b['p_max'] ? 1 : -1));

      var volume = 0.0;
      var points = [];

      buys.forEach(function (buy, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: buy['p_max'],
          y: volume,
        });

        if (buy['q_max_cda_copy'] !== undefined) {
          volume += buy['q_max_cda_copy'];
        } else {
          volume += buy['q_max'];
        }

        points.push({
          x: buy['p_max'],
          y: volume,
        });

      });

      // insert a horizontal line to 0 to show limit order
      points.push({
        x: 0.0,
        y: volume,
      });
    }

    if (MarketGraph.flipAxes) {
      for (let i = 0; i < points.length; i++) {
        var new_x = points[i].y;
        var new_y = points[i].x;
        points[i].y = new_y;
        points[i].x = new_x;
      }
    }

    chart.data.datasets[0].data = points;
    chart.update();
  }

  let lastDataToGraphAsks
  function graphAsks(chart, sells = null, regraph = false) {
    console.log("graphBids() sells:")
    console.log(sells)
    console.log("")

    if (regraph === true && sells === null) {
      if (chart.data.datasets[1].data.length === 0) {
        return
      }
      sells = lastDataToGraphAsks
    } else {
      lastDataToGraphAsks = sells
    }

    sells = sells.filter((sell) => sell['status'] == 'active');

    if ('{{treatment}}' != 'cda') {

      if (sells.length == 0) {
        chart.data.datasets[1].data = [];
        chart.update();
        return;
      }

      var points = [];
      var prices = [...Array(20).keys()];

      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;

        sells.forEach(function (sell, _index, _array) {
          agg_supply += calcSupply(sell, price);
        });

        points.push({
          x: price,
          y: agg_supply,
        });
      });

      if (MarketGraph.flipAxes) {
        for (let i = 0; i < points.length; i++) {
          var new_x = points[i].y;
          var new_y = points[i].x;
          points[i].y = new_y;
          points[i].x = new_x;
        }
      }

    } else {
      // Sort the asks in increasing order (lowest price first)
      sells.sort((a, b) => (a['p_max'] > b['p_max'] ? 1 : -1));

      var volume = 0.0;
      var points = [];

      sells.forEach(function (sell, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: sell['p_max'],
          y: volume,
        });

        if (sell['q_max_cda_copy'] !== undefined) {
          volume += sell['q_max_cda_copy'];
        } else {
          volume += sell['q_max'];
        }

        points.push({
          x: sell['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to max price = 130 to show limit order
      points.push({
        x: 20.0,
        y: volume,
      });

      if (MarketGraph.flipAxes) {
        for (let i = 0; i < points.length; i++) {
          var new_x = points[i].y;
          var new_y = points[i].x;
          points[i].y = new_y;
          points[i].x = new_x;
        }
      }
    }

    chart.data.datasets[1].data = points;
    chart.update();
  }

  // adds to the player's profit
  function updateProfit(chart, profit) {
    let dataset = chart.series[0];
    const profitFormatted = parseFloat(profit.toFixed(2));
    dataset.addPoint(profitFormatted);
  }

  // Adds or subtracts volume to trader
  function updateVolume(chart, volume) {
    let dataset = chart.series[0];
    const volumeFormated = parseFloat(volume.toFixed(2));
    dataset.addPoint(volumeFormated);
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  class BetsUI {
    static #recentBet = null;

    static moveExpiredBet(bet) {
      const id = bet.bet_id;
      this.#removeFromActive(id);
      this.#appendToExpired();

    }

    static getUpcomingBetData() {
      const table = document.querySelector('#activeBets');

      if (table.children.length === 0) return null

      const upcomingBet = table.firstElementChild
      console.log("got bet", upcomingBet)

      const data = {
        quantity: parseFloat(upcomingBet.querySelector(".betQuantity").textContent),
        price: parseFloat(upcomingBet.querySelector(".betPrice").textContent),
        direction: upcomingBet.querySelector(".betDirection").textContent.trim(),
      }

      console.log("got data", data)
      return data
    }

    static #removeFromActive(id) {
      this.#recentBet = document.querySelector(`#a${id}`).cloneNode(true);
      document.querySelector(`#a${id}`).remove();
    }

    static #appendToExpired() {
      const table = document.querySelector('#executedBetsTable');
      table.appendChild(this.#recentBet);
    }

    static convertDeadlinesToSeconds() {
      const rows = [...document.getElementsByClassName('betDeadline')];
      rows.forEach((row) => {
        const ms = math.unit(row.textContent);
        const s = ms.to('s').toString();
        row.textContent = s;
      });
    }

    static decrementDeadlines() {
      const rows = [...document.getElementsByClassName('betDeadline')];
      const zeroSeconds = math.unit('0s');

      rows.forEach((row) => {
        const s = math.unit(row.textContent);
        if (s.equals(zeroSeconds)) return;

        const updatedS = math.subtract(s, math.unit('1s'));
        row.textContent = updatedS.toString();
      });
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function liveRecv(data) {
    // This was a hack for preventing previous update()'s from affecting the current round
    // A better solution would be to just find a way to get a reference to the interval in the backend and delete it before moving on to the next round
    // if (ROUND_NUMBER !== data['round']) {
    //   // console.log("wrong round")
    //   console.log("data", data)
    //   return;
    // }

    if (data['type'] == 'begin') {
      console.log('Round begin');
    }

    if (data['type'] == 'clear') {
      // to continually move time in the cash and inv graphs, 
      // update cash and inventory bar regardless of changes to cash and inv
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);

      // clear book graph
      klf_line.data.datasets[2].data = [];
      klf_line.update();

      // lastDataToGraphClearingPrice

      const d = data["payoff_data"]

      const payoff = document.querySelectorAll(".payoff")
      for (let i = 0; i < payoff.length; i++) payoff[i].innerText = d["payoff"]

      const a = document.querySelectorAll(".a")
      for (let i = 0; i < a.length; i++) a[i].innerText = d["endowment"] + d["money_gained_in_market"] - d["money_lost_in_market"]

      const b = document.querySelectorAll(".b")
      for (let i = 0; i < b.length; i++) b[i].innerText = d["money_gained_from_buy_bets"] - d["money_lost_from_sell_bets"]

      const c = document.querySelectorAll(".c")
      for (let i = 0; i < c.length; i++) c[i].innerText = d["c_bar"] * -d["negative_inventory"]

      document.querySelector(".endowment").innerText = d["endowment"]
      document.querySelector(".money_gained_in_market").innerText = d["money_gained_in_market"]
      document.querySelector(".money_lost_in_market").innerText = d["money_lost_in_market"]
      document.querySelector(".money_gained_from_buy_bets").innerText = d["money_gained_from_buy_bets"]
      document.querySelector(".money_lost_from_sell_bets").innerText = d["money_lost_from_sell_bets"]
      document.querySelector(".c_bar").innerText = d["c_bar"]
      document.querySelector(".negative_inventory").innerText = d["negative_inventory"]
    }

    // check if any orders in our orderHistory have expired
    // if so, then get rid of it
    if (data['type'] === 'regraph') {
      console.log("*regraph")
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
      updateOrderHistory(data);
      console.log("order expired here's the data", data)
    }

    if (data['type'] == 'buy' || data['type'] == 'sell') {
      console.log("*incoming data:")
      console.log(data)

      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }

    if (data['type'] == 'clearing_price') {
      console.log("*graph got clearing price")
      global_clearing_price = data['clearing_price'];
      if ('{{treatment}}' != 'cda') {
        graphClearingPrice(
          klf_line,
          data['clearing_price'],
          data['buys'],
          data['sells']
        );
      }
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }

    if (data['type'] == 'bets update') {
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedDataForOdometer = data;
      cash = data['cash']
      inventory = data['inventory']
      BetsUI.moveExpiredBet(data['bet']);
    }

    if (data['type'] == 'update') {
      console.log("*graph update")
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedDataForOdometer = data;
      cash = data['cash']
      inventory = data['inventory']

      const d = data["payoff_data"]
      const payoff = document.querySelectorAll(".payoff")
      for (let i = 0; i < payoff.length; i++) payoff[i].innerText = d["payoff"]

      const a = document.querySelectorAll(".a")
      for (let i = 0; i < a.length; i++) a[i].innerText = d["endowment"] + d["money_gained_in_market"] - d["money_lost_in_market"]

      const b = document.querySelectorAll(".b")
      for (let i = 0; i < b.length; i++) b[i].innerText = d["money_gained_from_buy_bets"] - d["money_lost_from_sell_bets"]

      const c = document.querySelectorAll(".c")
      for (let i = 0; i < c.length; i++) c[i].innerText = d["c_bar"] * -d["negative_inventory"]

      document.querySelector(".endowment").innerText = d["endowment"]
      document.querySelector(".money_gained_in_market").innerText = d["money_gained_in_market"]
      document.querySelector(".money_lost_in_market").innerText = d["money_lost_in_market"]
      document.querySelector(".money_gained_from_buy_bets").innerText = d["money_gained_from_buy_bets"]
      document.querySelector(".money_lost_from_sell_bets").innerText = d["money_lost_from_sell_bets"]
      document.querySelector(".c_bar").innerText = d["c_bar"]
      document.querySelector(".negative_inventory").innerText = d["negative_inventory"]
    }

    tickCount++
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  let cachedDataForOdometer;
  let cash = 0
  let inventory = 0
  function updateCashAndInventoryDisplay(data) {
    if (cachedDataForOdometer === undefined) return;

    cashOdometer.update(parseFloat(cash).toFixed(2));
    invOdometer.update(parseFloat(inventory).toFixed(2));

  }

  function appendActiveOrdersTable(order) {
    const table = document.querySelector('#activeOrdersTable');
    const newRow = document.createElement('tr');

    const direction = document.createElement('td');
    direction.innerHTML = order.direction === 'buy' ? 'Buy' : 'Sell';

    const price = document.createElement('td');
    price.innerHTML =
      order.p_min === order.p_max
        ? `${order.p_max}`
        : `${order.p_min}-${order.p_max}`;

    const quantity = document.createElement('td');
    quantity.innerHTML = order.q_max;

    if (isFLO) {
      const rate = document.createElement('td');
      rate.innerHTML = order.u_max;

      direction.style.width = '92px';
      price.style.width = '62px';
      quantity.style.width = '90px';
      rate.style.width = '59px';
      newRow.append(direction, price, quantity, rate);
    } else {
      direction.style.width = '91px';
      price.style.width = '61px';
      quantity.style.width = '88px';
      newRow.append(direction, price, quantity);
    }

    // since ids cannot start with number
    newRow.id = 'a' + order.orderID;
    const tableWrapper = document.querySelector('#activeOrdersTableWrapper');

    table.appendChild(newRow);
  }

  if (isCDA || isFBA) {
    hideRateColumnActiveOrdersTable();
  }

  function removeActiveOrderTable(orderID) {
    const rowCopy = document.querySelector(`#a${orderID}`).cloneNode(true);
    document.querySelector(`#a${orderID}`).remove();

    const table = document.querySelector('#executedOrdersTable');
    table.appendChild(rowCopy);

    return rowCopy
    updateCashAfterBet
  }

  function hideRateColumnActiveOrdersTable() {
    document.querySelector('#activeOrdersRate').remove();
    document.querySelector('#activeOrdersDirection').style.width = '0';
  }

  function debug() { }
</script>
<!-- <script src="{% static 'flow_market/react.js' %}"></script> -->